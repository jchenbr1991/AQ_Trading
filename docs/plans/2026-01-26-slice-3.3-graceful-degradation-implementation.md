# Slice 3.3: Graceful Degradation Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement production hardening that handles failures gracefully with Central Policy + Local Execution architecture.

**Architecture:** SystemStateService as single source of truth, TradingGate for unified permissions, Circuit Breakers for component-level failure detection, EventBus for non-blocking event propagation, and Recovery Orchestrator for staged recovery.

**Tech Stack:** Python 3.11+ (FastAPI, SQLAlchemy, asyncio), TypeScript (React, TanStack Query), PostgreSQL/TimescaleDB

**Design Document:** `docs/plans/2026-01-26-graceful-degradation-design.md`

---

## Task 1: Backend Models

**Files:**
- Create: `backend/src/degradation/__init__.py`
- Create: `backend/src/degradation/models.py`
- Test: `backend/tests/degradation/test_models.py`

**Step 1: Create test file with model tests**

```python
# backend/tests/degradation/test_models.py
"""Tests for degradation models."""

import time
from datetime import datetime, timezone

import pytest

from src.degradation.models import (
    ActionType,
    ComponentSource,
    EventType,
    MODE_PRIORITY,
    MUST_DELIVER_EVENTS,
    ReasonCode,
    RecoveryStage,
    RecoveryTrigger,
    Severity,
    SystemEvent,
    SystemLevel,
    SystemMode,
)


class TestSystemMode:
    """Tests for SystemMode enum."""

    def test_all_modes_defined(self):
        """All 6 modes should be defined."""
        assert len(SystemMode) == 6
        assert SystemMode.NORMAL.value == "normal"
        assert SystemMode.DEGRADED.value == "degraded"
        assert SystemMode.SAFE_MODE.value == "safe_mode"
        assert SystemMode.SAFE_MODE_DISCONNECTED.value == "safe_mode_disconnected"
        assert SystemMode.HALT.value == "halt"
        assert SystemMode.RECOVERING.value == "recovering"


class TestModePriority:
    """Tests for MODE_PRIORITY conflict resolution."""

    def test_priority_order(self):
        """HALT should be highest priority, NORMAL lowest."""
        assert MODE_PRIORITY[SystemMode.NORMAL] == 0
        assert MODE_PRIORITY[SystemMode.RECOVERING] == 1
        assert MODE_PRIORITY[SystemMode.DEGRADED] == 2
        assert MODE_PRIORITY[SystemMode.SAFE_MODE] == 3
        assert MODE_PRIORITY[SystemMode.SAFE_MODE_DISCONNECTED] == 4
        assert MODE_PRIORITY[SystemMode.HALT] == 5

    def test_conflict_resolution_takes_max(self):
        """Conflict resolution should take most severe mode."""
        modes = [SystemMode.DEGRADED, SystemMode.SAFE_MODE, SystemMode.NORMAL]
        result = max(modes, key=lambda m: MODE_PRIORITY[m])
        assert result == SystemMode.SAFE_MODE


class TestSystemLevel:
    """Tests for SystemLevel enum."""

    def test_all_levels_defined(self):
        """All 3 levels should be defined."""
        assert len(SystemLevel) == 3
        assert SystemLevel.HEALTHY.value == "healthy"
        assert SystemLevel.UNSTABLE.value == "unstable"
        assert SystemLevel.TRIPPED.value == "tripped"


class TestRecoveryStage:
    """Tests for RecoveryStage enum."""

    def test_all_stages_defined(self):
        """All 4 stages should be defined."""
        assert len(RecoveryStage) == 4
        assert RecoveryStage.CONNECT_BROKER.value == "connect_broker"
        assert RecoveryStage.CATCHUP_MARKETDATA.value == "catchup_marketdata"
        assert RecoveryStage.VERIFY_RISK.value == "verify_risk"
        assert RecoveryStage.READY.value == "ready"


class TestSystemEvent:
    """Tests for SystemEvent dataclass."""

    def test_create_event(self):
        """SystemEvent should be creatable with required fields."""
        now_wall = datetime.now(tz=timezone.utc)
        now_mono = time.monotonic()

        event = SystemEvent(
            event_type=EventType.FAIL_CRIT,
            source=ComponentSource.BROKER,
            severity=Severity.CRITICAL,
            reason_code=ReasonCode.BROKER_DISCONNECT,
            event_time_wall=now_wall,
            event_time_mono=now_mono,
        )

        assert event.event_type == EventType.FAIL_CRIT
        assert event.source == ComponentSource.BROKER
        assert event.reason_code == ReasonCode.BROKER_DISCONNECT
        assert event.details is None
        assert event.ttl_seconds is None

    def test_is_critical_whitelist(self):
        """Only whitelisted events should be critical."""
        now_wall = datetime.now(tz=timezone.utc)
        now_mono = time.monotonic()

        # Critical event (in whitelist)
        critical_event = SystemEvent(
            event_type=EventType.FAIL_CRIT,
            source=ComponentSource.BROKER,
            severity=Severity.CRITICAL,
            reason_code=ReasonCode.BROKER_DISCONNECT,
            event_time_wall=now_wall,
            event_time_mono=now_mono,
        )
        assert critical_event.is_critical() is True

        # Non-critical event (not in whitelist)
        non_critical_event = SystemEvent(
            event_type=EventType.FAIL_SUPP,
            source=ComponentSource.ALERTS,
            severity=Severity.WARNING,
            reason_code=ReasonCode.ALERTS_CHANNEL_DOWN,
            event_time_wall=now_wall,
            event_time_mono=now_mono,
        )
        assert non_critical_event.is_critical() is False

    def test_must_deliver_events_whitelist(self):
        """MUST_DELIVER_EVENTS should contain only critical events."""
        assert ReasonCode.BROKER_DISCONNECT in MUST_DELIVER_EVENTS
        assert ReasonCode.POSITION_TRUTH_UNKNOWN in MUST_DELIVER_EVENTS
        assert ReasonCode.BROKER_REPORT_MISMATCH in MUST_DELIVER_EVENTS
        assert ReasonCode.RISK_BREACH_HARD in MUST_DELIVER_EVENTS
        # Non-critical should not be in whitelist
        assert ReasonCode.ALERTS_CHANNEL_DOWN not in MUST_DELIVER_EVENTS
        assert ReasonCode.MD_QUALITY_DEGRADED not in MUST_DELIVER_EVENTS
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/degradation/test_models.py -v`
Expected: FAIL with "ModuleNotFoundError: No module named 'src.degradation'"

**Step 3: Create models.py with all enums and dataclasses**

```python
# backend/src/degradation/models.py
"""Degradation models for the trading system.

This module defines the core data structures for graceful degradation:
- SystemMode: System operating modes (NORMAL, DEGRADED, SAFE_MODE, etc.)
- SystemLevel: Internal health levels for hysteresis (HEALTHY, UNSTABLE, TRIPPED)
- RecoveryStage: Recovery orchestration stages
- SystemEvent: Events that trigger mode transitions
- ComponentSource: Sources of system events
- ReasonCode: Reason codes for mode transitions
"""

import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any
from uuid import UUID, uuid4


class SystemMode(str, Enum):
    """System operating modes.

    NORMAL: Full functionality, all operations allowed
    DEGRADED: Limited functionality, some restrictions apply
    SAFE_MODE: Protect capital, no new positions (control plane available)
    SAFE_MODE_DISCONNECTED: Protect capital (control plane unavailable)
    HALT: All operations suspended, manual intervention required
    RECOVERING: System recovery in progress
    """

    NORMAL = "normal"
    DEGRADED = "degraded"
    SAFE_MODE = "safe_mode"
    SAFE_MODE_DISCONNECTED = "safe_mode_disconnected"
    HALT = "halt"
    RECOVERING = "recovering"


# Mode priority for conflict resolution (higher = more severe)
MODE_PRIORITY: dict[SystemMode, int] = {
    SystemMode.NORMAL: 0,
    SystemMode.RECOVERING: 1,
    SystemMode.DEGRADED: 2,
    SystemMode.SAFE_MODE: 3,
    SystemMode.SAFE_MODE_DISCONNECTED: 4,
    SystemMode.HALT: 5,
}


class SystemLevel(str, Enum):
    """Internal health level for hysteresis tracking.

    HEALTHY: Component is operating normally
    UNSTABLE: Component is experiencing issues, not yet tripped
    TRIPPED: Component has failed, degradation triggered
    """

    HEALTHY = "healthy"
    UNSTABLE = "unstable"
    TRIPPED = "tripped"


class RecoveryStage(str, Enum):
    """Recovery orchestration stages.

    Stages progress in order: CONNECT_BROKER -> CATCHUP_MARKETDATA -> VERIFY_RISK -> READY
    """

    CONNECT_BROKER = "connect_broker"
    CATCHUP_MARKETDATA = "catchup_marketdata"
    VERIFY_RISK = "verify_risk"
    READY = "ready"


class RecoveryTrigger(str, Enum):
    """How recovery was triggered."""

    AUTO = "auto"  # Automatic after failure recovery
    MANUAL = "manual"  # Manual operator intervention
    COLD_START = "cold_start"  # System startup


class EventType(str, Enum):
    """Types of system events."""

    FAIL_CRIT = "fail_crit"  # Critical failure
    FAIL_SUPP = "fail_supp"  # Support component failure
    RECOVERED = "recovered"  # Component recovered
    HEARTBEAT = "heartbeat"  # Health heartbeat
    QUALITY_DEGRADED = "quality_degraded"  # Quality degradation


class ComponentSource(str, Enum):
    """Sources of system events."""

    BROKER = "broker"
    MARKET_DATA = "market_data"
    RISK = "risk"
    DB = "db"
    ALERTS = "alerts"
    SYSTEM = "system"


class Severity(str, Enum):
    """Event severity levels."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


class ReasonCode(str, Enum):
    """Reason codes for mode transitions.

    These map to specific failure scenarios and determine target mode via Decision Matrix.
    """

    # Broker
    BROKER_DISCONNECT = "broker.disconnect"
    BROKER_RECONNECTED = "broker.reconnected"
    BROKER_REPORT_MISMATCH = "broker.mismatch"

    # Market Data
    MD_STALE = "market_data.stale"
    MD_QUALITY_DEGRADED = "market_data.quality_low"

    # Risk
    RISK_TIMEOUT = "risk.timeout"
    RISK_BREACH_HARD = "risk.breach_hard"

    # Position
    POSITION_TRUTH_UNKNOWN = "position.unknown"

    # Database
    DB_WRITE_FAIL_BUFFERED = "db.write_fail_buffered"
    DB_BUFFER_OVERFLOW = "db.buffer_overflow"

    # Alerts
    ALERTS_CHANNEL_DOWN = "alerts.channel_down"

    # Recovery
    RECOVERY_FAILED = "recovery.failed"
    RECOVERY_COMPLETE = "recovery.complete"

    # System
    ALL_HEALTHY = "all.healthy"
    COLD_START = "cold_start"
    FORCE_OVERRIDE = "force_override"


# Must-deliver events whitelist (only these trigger local emergency degrade)
MUST_DELIVER_EVENTS: frozenset[ReasonCode] = frozenset({
    ReasonCode.BROKER_DISCONNECT,
    ReasonCode.POSITION_TRUTH_UNKNOWN,
    ReasonCode.BROKER_REPORT_MISMATCH,
    ReasonCode.RISK_BREACH_HARD,
})


class ActionType(str, Enum):
    """Trading action types for gate permission checks."""

    OPEN = "open"
    SEND = "send"
    AMEND = "amend"
    CANCEL = "cancel"
    REDUCE_ONLY = "reduce_only"
    QUERY = "query"


@dataclass
class SystemEvent:
    """Event representing a system state change.

    Uses dual timestamps:
    - event_time_wall: For display/audit (may jump with clock sync)
    - event_time_mono: For logic/hysteresis/TTL (monotonic, never jumps)
    """

    event_type: EventType
    source: ComponentSource
    severity: Severity
    reason_code: ReasonCode
    event_time_wall: datetime
    event_time_mono: float

    event_id: UUID = field(default_factory=uuid4)
    details: dict[str, Any] | None = None
    ttl_seconds: int | None = None

    def is_critical(self) -> bool:
        """Check if this event requires must-deliver handling."""
        return self.reason_code in MUST_DELIVER_EVENTS

    def is_expired(self, current_mono: float | None = None) -> bool:
        """Check if event TTL has expired using monotonic time."""
        if self.ttl_seconds is None:
            return False
        if current_mono is None:
            current_mono = time.monotonic()
        elapsed = current_mono - self.event_time_mono
        return elapsed > self.ttl_seconds


@dataclass
class ModeTransition:
    """Record of a mode transition."""

    from_mode: SystemMode
    to_mode: SystemMode
    reason_code: ReasonCode
    source: ComponentSource
    timestamp_wall: datetime
    timestamp_mono: float
    operator_id: str | None = None
    override_ttl: int | None = None


@dataclass
class ComponentStatus:
    """Status of a single component."""

    source: ComponentSource
    level: SystemLevel
    last_event: SystemEvent | None
    last_update_mono: float
    consecutive_failures: int = 0
    unstable_since_mono: float | None = None


def create_event(
    event_type: EventType,
    source: ComponentSource,
    severity: Severity,
    reason_code: ReasonCode,
    details: dict[str, Any] | None = None,
    ttl_seconds: int | None = None,
) -> SystemEvent:
    """Create a SystemEvent with current timestamps.

    Factory function that automatically sets wall and monotonic timestamps.
    """
    return SystemEvent(
        event_type=event_type,
        source=source,
        severity=severity,
        reason_code=reason_code,
        event_time_wall=datetime.now(tz=timezone.utc),
        event_time_mono=time.monotonic(),
        details=details,
        ttl_seconds=ttl_seconds,
    )
```

**Step 4: Create __init__.py with exports**

```python
# backend/src/degradation/__init__.py
"""Graceful Degradation module for the trading system.

This module implements production hardening with Central Policy + Local Execution:
- SystemStateService: Central state management (single source of truth)
- TradingGate: Unified gate for all trading operations
- Circuit Breakers: Component-level failure detection
- EventBus: Non-blocking event propagation
- Recovery Orchestrator: Staged recovery from failures

Architecture Principle:
    "没有任何一个组件，拥有把 Trading Hot Path 拉下水的权力。"
    (No component can drag down the Trading Hot Path.)

Usage:
    from src.degradation import (
        SystemMode,
        SystemLevel,
        get_system_state,
        get_trading_gate,
    )

    # Check if trading is allowed
    gate = get_trading_gate()
    if gate and gate.allows(ActionType.SEND):
        await broker.send_order(order)
"""

# Models
from src.degradation.models import (
    ActionType,
    ComponentSource,
    ComponentStatus,
    EventType,
    MODE_PRIORITY,
    MUST_DELIVER_EVENTS,
    ModeTransition,
    ReasonCode,
    RecoveryStage,
    RecoveryTrigger,
    Severity,
    SystemEvent,
    SystemLevel,
    SystemMode,
    create_event,
)

__all__ = [
    # Enums
    "SystemMode",
    "SystemLevel",
    "RecoveryStage",
    "RecoveryTrigger",
    "EventType",
    "ComponentSource",
    "Severity",
    "ReasonCode",
    "ActionType",
    # Constants
    "MODE_PRIORITY",
    "MUST_DELIVER_EVENTS",
    # Dataclasses
    "SystemEvent",
    "ModeTransition",
    "ComponentStatus",
    # Factory
    "create_event",
]
```

**Step 5: Run tests to verify they pass**

Run: `cd backend && pytest tests/degradation/test_models.py -v`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add backend/src/degradation/__init__.py backend/src/degradation/models.py backend/tests/degradation/test_models.py
git commit -m "feat(degradation): add core models for Slice 3.3

- SystemMode enum with 6 operating modes
- MODE_PRIORITY for conflict resolution
- SystemLevel for hysteresis tracking
- SystemEvent with dual timestamps (wall + mono)
- MUST_DELIVER_EVENTS whitelist for critical events
- RecoveryStage for recovery orchestration"
```

---

## Task 2: Backend Config

**Files:**
- Create: `backend/src/degradation/config.py`
- Test: `backend/tests/degradation/test_config.py`

**Step 1: Create test file**

```python
# backend/tests/degradation/test_config.py
"""Tests for degradation configuration."""

import pytest

from src.degradation.config import DegradationConfig, get_config


class TestDegradationConfig:
    """Tests for DegradationConfig dataclass."""

    def test_default_values(self):
        """Config should have sensible defaults."""
        config = DegradationConfig()

        # Hysteresis
        assert config.fail_threshold_count == 3
        assert config.fail_threshold_seconds == 5.0
        assert config.recovery_stable_seconds == 10.0
        assert config.min_safe_mode_seconds == 30.0

        # Timeouts
        assert config.broker_timeout_ms == 5000
        assert config.market_data_stale_ms == 10000
        assert config.risk_timeout_ms == 2000

        # Recovery
        assert config.auto_recovery_to_normal is True

        # DB Buffer
        assert config.db_buffer_max_entries == 1000
        assert config.db_buffer_max_bytes == 10_000_000

        # EventBus
        assert config.event_bus_queue_size == 10000
        assert config.event_bus_drop_on_full is True

    def test_config_immutable(self):
        """Config should be a frozen dataclass."""
        config = DegradationConfig()
        with pytest.raises(AttributeError):
            config.fail_threshold_count = 10

    def test_get_config_returns_singleton(self):
        """get_config should return the same instance."""
        config1 = get_config()
        config2 = get_config()
        assert config1 is config2
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/degradation/test_config.py -v`
Expected: FAIL with "cannot import name 'DegradationConfig'"

**Step 3: Create config.py**

```python
# backend/src/degradation/config.py
"""Degradation configuration.

All thresholds for graceful degradation must come from this config.
Hardcoding thresholds in code is PROHIBITED.

Usage:
    from src.degradation.config import get_config

    config = get_config()
    if stale_ms > config.market_data_stale_ms:
        # Trigger degradation
"""

from dataclasses import dataclass


@dataclass(frozen=True)
class DegradationConfig:
    """Configuration for graceful degradation.

    All thresholds and settings are defined here. Never hardcode thresholds
    elsewhere in the codebase - always reference this config.
    """

    # Hysteresis settings
    fail_threshold_count: int = 3  # N failures before UNSTABLE
    fail_threshold_seconds: float = 5.0  # or T seconds of failures
    recovery_stable_seconds: float = 10.0  # stable for T seconds before NORMAL
    min_safe_mode_seconds: float = 30.0  # minimum time in SAFE_MODE
    unknown_on_ttl_expiry: bool = True  # TTL expired -> UNKNOWN (not HEALTHY)
    alert_on_unstable: bool = True  # Send WARNING alert on UNSTABLE

    # Component timeouts
    broker_timeout_ms: int = 5000
    market_data_stale_ms: int = 10000
    risk_timeout_ms: int = 2000
    risk_timeout_consecutive_count: int = 3
    db_timeout_ms: int = 3000

    # Recovery settings
    max_recovery_attempts: int = 3
    recovery_backoff_base_ms: int = 1000
    auto_recovery_to_normal: bool = True  # READY stable -> NORMAL

    # DB Buffer settings
    db_buffer_max_entries: int = 1000  # Primary limit (recommended)
    db_buffer_max_bytes: int = 10_000_000  # 10MB (json.dumps size)
    db_buffer_max_seconds: float = 60.0
    db_wal_enabled: bool = True

    # EventBus settings
    event_bus_queue_size: int = 10000
    event_bus_publish_timeout_ms: int = 100
    event_bus_drop_on_full: bool = True  # Drop non-critical on full

    # Cache staleness thresholds
    position_cache_stale_ms: int = 30000
    market_data_cache_stale_ms: int = 10000

    # Default TTL for component status
    component_status_ttl_seconds: int = 30


# Global config instance
_config: DegradationConfig | None = None


def get_config() -> DegradationConfig:
    """Get the global degradation config instance.

    Returns:
        The singleton DegradationConfig instance.
    """
    global _config
    if _config is None:
        _config = DegradationConfig()
    return _config


def set_config(config: DegradationConfig) -> None:
    """Set the global degradation config (for testing).

    Args:
        config: The config instance to use.
    """
    global _config
    _config = config
```

**Step 4: Update __init__.py exports**

Add to `backend/src/degradation/__init__.py`:

```python
# Config
from src.degradation.config import DegradationConfig, get_config, set_config

# Add to __all__
__all__ = [
    # ... existing exports ...
    # Config
    "DegradationConfig",
    "get_config",
    "set_config",
]
```

**Step 5: Run tests**

Run: `cd backend && pytest tests/degradation/test_config.py -v`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add backend/src/degradation/config.py backend/tests/degradation/test_config.py backend/src/degradation/__init__.py
git commit -m "feat(degradation): add configuration with all thresholds

- DegradationConfig frozen dataclass with all settings
- Hysteresis, timeout, recovery, buffer, and cache thresholds
- Singleton pattern via get_config()
- No hardcoded thresholds allowed elsewhere"
```

---

## Task 3: Backend EventBus

**Files:**
- Create: `backend/src/degradation/event_bus.py`
- Test: `backend/tests/degradation/test_event_bus.py`

**Step 1: Create test file**

```python
# backend/tests/degradation/test_event_bus.py
"""Tests for EventBus."""

import asyncio
import time
from datetime import datetime, timezone
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from src.degradation.config import DegradationConfig
from src.degradation.event_bus import EventBus, EventBusError
from src.degradation.models import (
    ComponentSource,
    EventType,
    ReasonCode,
    Severity,
    SystemEvent,
)


def make_event(reason_code: ReasonCode = ReasonCode.MD_STALE) -> SystemEvent:
    """Create a test event."""
    return SystemEvent(
        event_type=EventType.FAIL_SUPP,
        source=ComponentSource.MARKET_DATA,
        severity=Severity.WARNING,
        reason_code=reason_code,
        event_time_wall=datetime.now(tz=timezone.utc),
        event_time_mono=time.monotonic(),
    )


class TestEventBusPublish:
    """Tests for EventBus.publish()."""

    @pytest.mark.asyncio
    async def test_publish_success(self):
        """Publish should add event to queue."""
        config = DegradationConfig(event_bus_queue_size=10)
        bus = EventBus(config)

        event = make_event()
        result = await bus.publish(event)

        assert result is True
        assert bus.pending_count == 1

    @pytest.mark.asyncio
    async def test_publish_non_blocking(self):
        """Publish must be non-blocking (nowait)."""
        config = DegradationConfig(event_bus_queue_size=1)
        bus = EventBus(config)

        # Fill queue
        await bus.publish(make_event())
        assert bus.pending_count == 1

        # Second publish should not block, should drop
        event = make_event()
        result = await bus.publish(event)

        assert result is False
        assert bus.drop_count == 1

    @pytest.mark.asyncio
    async def test_drop_on_full_non_critical(self):
        """Non-critical events should be dropped when queue is full."""
        config = DegradationConfig(event_bus_queue_size=1, event_bus_drop_on_full=True)
        bus = EventBus(config)

        await bus.publish(make_event())

        # Non-critical event
        non_critical = make_event(ReasonCode.ALERTS_CHANNEL_DOWN)
        result = await bus.publish(non_critical)

        assert result is False
        assert bus.drop_count == 1

    @pytest.mark.asyncio
    async def test_critical_event_triggers_local_fallback(self):
        """Critical events should trigger local emergency degrade when dropped."""
        config = DegradationConfig(event_bus_queue_size=1)
        bus = EventBus(config)
        bus._local_emergency_degrade = MagicMock()

        await bus.publish(make_event())

        # Critical event (in MUST_DELIVER whitelist)
        critical = make_event(ReasonCode.BROKER_DISCONNECT)
        result = await bus.publish(critical)

        assert result is False
        bus._local_emergency_degrade.assert_called_once_with(critical)


class TestEventBusSubscribe:
    """Tests for EventBus.subscribe()."""

    @pytest.mark.asyncio
    async def test_subscribe_receives_events(self):
        """Subscriber should receive published events."""
        config = DegradationConfig(event_bus_queue_size=10)
        bus = EventBus(config)

        received = []

        async def handler(event: SystemEvent):
            received.append(event)

        bus.subscribe(handler)
        await bus.start()

        event = make_event()
        await bus.publish(event)

        # Allow event loop to process
        await asyncio.sleep(0.01)
        await bus.stop()

        assert len(received) == 1
        assert received[0].event_id == event.event_id


class TestEventBusFallback:
    """Tests for EventBus fallback mechanisms."""

    @pytest.mark.asyncio
    async def test_fallback_log_on_drop(self):
        """Dropped events should be logged to fallback."""
        config = DegradationConfig(event_bus_queue_size=1)
        bus = EventBus(config)
        bus._write_fallback_log = MagicMock()

        await bus.publish(make_event())

        # Drop event
        dropped = make_event()
        await bus.publish(dropped)

        bus._write_fallback_log.assert_called_once()
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/degradation/test_event_bus.py -v`
Expected: FAIL with "cannot import name 'EventBus'"

**Step 3: Create event_bus.py**

```python
# backend/src/degradation/event_bus.py
"""EventBus for non-blocking event propagation.

The EventBus is responsible for distributing SystemEvents to subscribers
without blocking the trading hot path. Key behaviors:

- Publish is ALWAYS non-blocking (put_nowait)
- Non-critical events are dropped when queue is full
- Critical events trigger local emergency degrade when dropped
- Fallback logging when events are dropped

Usage:
    from src.degradation.event_bus import EventBus

    bus = EventBus(config)
    bus.subscribe(handle_event)
    await bus.start()

    await bus.publish(event)  # Never blocks
"""

import asyncio
import json
import logging
from collections.abc import Awaitable, Callable
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

from src.degradation.config import DegradationConfig
from src.degradation.models import SystemEvent, SystemMode

logger = logging.getLogger(__name__)

EventHandler = Callable[[SystemEvent], Awaitable[None]]


class EventBusError(Exception):
    """EventBus operation error."""

    pass


class EventBus:
    """Non-blocking event distribution bus.

    Attributes:
        drop_count: Number of events dropped due to full queue.
        pending_count: Number of events waiting in queue.
    """

    def __init__(
        self,
        config: DegradationConfig,
        fallback_log_path: Path | None = None,
    ) -> None:
        """Initialize EventBus.

        Args:
            config: Degradation configuration.
            fallback_log_path: Path for fallback log file.
        """
        self._config = config
        self._queue: asyncio.Queue[SystemEvent] = asyncio.Queue(
            maxsize=config.event_bus_queue_size
        )
        self._subscribers: list[EventHandler] = []
        self._drop_count = 0
        self._running = False
        self._task: asyncio.Task | None = None
        self._fallback_log_path = fallback_log_path or Path("logs/event_bus_fallback.jsonl")

        # Callback for local emergency degrade (set by SystemStateService)
        self._emergency_degrade_callback: Callable[[SystemEvent], None] | None = None

    @property
    def drop_count(self) -> int:
        """Number of events dropped."""
        return self._drop_count

    @property
    def pending_count(self) -> int:
        """Number of events waiting in queue."""
        return self._queue.qsize()

    def subscribe(self, handler: EventHandler) -> None:
        """Subscribe to events.

        Args:
            handler: Async function to call for each event.
        """
        self._subscribers.append(handler)

    def set_emergency_callback(
        self, callback: Callable[[SystemEvent], None]
    ) -> None:
        """Set callback for emergency local degrade.

        Args:
            callback: Function to call when critical event is dropped.
        """
        self._emergency_degrade_callback = callback

    async def publish(self, event: SystemEvent) -> bool:
        """Publish event to queue (non-blocking).

        CRITICAL: This method NEVER blocks. Uses put_nowait internally.

        Args:
            event: The event to publish.

        Returns:
            True if event was queued, False if dropped.
        """
        try:
            self._queue.put_nowait(event)
            return True
        except asyncio.QueueFull:
            self._drop_count += 1

            if event.is_critical():
                # Critical events must have an effect
                self._local_emergency_degrade(event)
            else:
                # Non-critical events just get logged
                self._write_fallback_log("QueueFull", event)

            logger.warning(
                "EventBus queue full, dropped event: %s (critical=%s)",
                event.reason_code,
                event.is_critical(),
            )
            return False

    def _local_emergency_degrade(self, event: SystemEvent) -> None:
        """Trigger local emergency degrade for critical event.

        Called when a critical event cannot be queued. This ensures
        the system still degrades even if the event bus is overwhelmed.
        """
        logger.critical(
            "Local emergency degrade triggered: %s from %s",
            event.reason_code,
            event.source,
        )
        self._write_fallback_log("EmergencyDegrade", event)

        if self._emergency_degrade_callback:
            try:
                self._emergency_degrade_callback(event)
            except Exception as e:
                logger.exception("Emergency degrade callback failed: %s", e)

    def _write_fallback_log(self, reason: str, event: SystemEvent) -> None:
        """Write event to fallback log file.

        Used when events are dropped. This ensures we have a record
        even if the main event pipeline is overwhelmed.
        """
        try:
            self._fallback_log_path.parent.mkdir(parents=True, exist_ok=True)

            entry = {
                "timestamp": datetime.now(tz=timezone.utc).isoformat(),
                "reason": reason,
                "event_id": str(event.event_id),
                "event_type": event.event_type.value,
                "source": event.source.value,
                "reason_code": event.reason_code.value,
                "severity": event.severity.value,
                "is_critical": event.is_critical(),
            }

            with open(self._fallback_log_path, "a") as f:
                f.write(json.dumps(entry) + "\n")
        except Exception as e:
            # Last resort - just log to stderr
            logger.exception("Failed to write fallback log: %s", e)

    async def start(self) -> None:
        """Start the event distribution loop."""
        if self._running:
            return

        self._running = True
        self._task = asyncio.create_task(self._run_loop())
        logger.info("EventBus started")

    async def stop(self) -> None:
        """Stop the event distribution loop."""
        self._running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        logger.info("EventBus stopped")

    async def _run_loop(self) -> None:
        """Main event distribution loop."""
        while self._running:
            try:
                event = await asyncio.wait_for(
                    self._queue.get(),
                    timeout=1.0,
                )
                await self._dispatch(event)
            except asyncio.TimeoutError:
                continue
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.exception("EventBus loop error: %s", e)

    async def _dispatch(self, event: SystemEvent) -> None:
        """Dispatch event to all subscribers."""
        for handler in self._subscribers:
            try:
                await handler(event)
            except Exception as e:
                logger.exception(
                    "EventBus handler error for %s: %s",
                    event.reason_code,
                    e,
                )
```

**Step 4: Update __init__.py**

Add to exports:
```python
from src.degradation.event_bus import EventBus, EventBusError
```

**Step 5: Run tests**

Run: `cd backend && pytest tests/degradation/test_event_bus.py -v`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add backend/src/degradation/event_bus.py backend/tests/degradation/test_event_bus.py backend/src/degradation/__init__.py
git commit -m "feat(degradation): add EventBus with drop-on-full behavior

- Non-blocking publish (put_nowait always)
- Drop-on-full for non-critical events
- Local emergency degrade for critical events
- Fallback log for dropped events"
```

---

## Task 4: Backend TradingGate

**Files:**
- Create: `backend/src/degradation/trading_gate.py`
- Test: `backend/tests/degradation/test_trading_gate.py`

**Step 1: Create test file**

```python
# backend/tests/degradation/test_trading_gate.py
"""Tests for TradingGate."""

import pytest

from src.degradation.models import ActionType, RecoveryStage, SystemMode
from src.degradation.trading_gate import TradingGate


class TestTradingGatePermissions:
    """Tests for TradingGate permission checks."""

    def test_normal_mode_all_allowed(self):
        """NORMAL mode should allow all actions."""
        gate = TradingGate()
        gate.update_mode(SystemMode.NORMAL)

        for action in ActionType:
            assert gate.allows(action) is True

    def test_degraded_mode_limited(self):
        """DEGRADED mode should allow most actions with restrictions."""
        gate = TradingGate()
        gate.update_mode(SystemMode.DEGRADED)

        assert gate.allows(ActionType.SEND) is True
        assert gate.allows(ActionType.CANCEL) is True
        assert gate.allows(ActionType.QUERY) is True
        # Open is restricted (returns True but with warning)
        allowed, warning = gate.allows_with_warning(ActionType.OPEN)
        assert allowed is True
        assert warning is not None

    def test_safe_mode_no_new_positions(self):
        """SAFE_MODE should block new positions."""
        gate = TradingGate()
        gate.update_mode(SystemMode.SAFE_MODE)

        assert gate.allows(ActionType.OPEN) is False
        assert gate.allows(ActionType.SEND) is False
        assert gate.allows(ActionType.AMEND) is False
        assert gate.allows(ActionType.CANCEL) is True
        assert gate.allows(ActionType.REDUCE_ONLY) is True
        assert gate.allows(ActionType.QUERY) is True

    def test_safe_mode_cancel_best_effort(self):
        """SAFE_MODE cancel should include best-effort warning."""
        gate = TradingGate()
        gate.update_mode(SystemMode.SAFE_MODE)

        allowed, warning = gate.allows_with_warning(ActionType.CANCEL)
        assert allowed is True
        assert "best-effort" in warning.lower()

    def test_safe_mode_disconnected_minimal(self):
        """SAFE_MODE_DISCONNECTED should only allow local query."""
        gate = TradingGate()
        gate.update_mode(SystemMode.SAFE_MODE_DISCONNECTED)

        assert gate.allows(ActionType.OPEN) is False
        assert gate.allows(ActionType.SEND) is False
        assert gate.allows(ActionType.CANCEL) is False
        assert gate.allows(ActionType.QUERY) is True  # Local only

        allowed, warning = gate.allows_with_warning(ActionType.CANCEL)
        assert allowed is False
        assert "disconnected" in warning.lower()

    def test_halt_mode_query_only(self):
        """HALT mode should only allow query."""
        gate = TradingGate()
        gate.update_mode(SystemMode.HALT)

        assert gate.allows(ActionType.OPEN) is False
        assert gate.allows(ActionType.SEND) is False
        assert gate.allows(ActionType.CANCEL) is False
        assert gate.allows(ActionType.QUERY) is True


class TestTradingGateRecovery:
    """Tests for TradingGate recovery stage permissions."""

    def test_recovery_connect_broker_stage(self):
        """CONNECT_BROKER stage should only allow query."""
        gate = TradingGate()
        gate.update_mode(SystemMode.RECOVERING, RecoveryStage.CONNECT_BROKER)

        assert gate.allows(ActionType.QUERY) is True
        assert gate.allows(ActionType.CANCEL) is False
        assert gate.allows(ActionType.OPEN) is False

    def test_recovery_verify_risk_stage(self):
        """VERIFY_RISK stage should allow query and cancel."""
        gate = TradingGate()
        gate.update_mode(SystemMode.RECOVERING, RecoveryStage.VERIFY_RISK)

        assert gate.allows(ActionType.QUERY) is True
        assert gate.allows(ActionType.CANCEL) is True
        assert gate.allows(ActionType.OPEN) is False

    def test_recovery_ready_stage(self):
        """READY stage should allow query, cancel, reduce_only."""
        gate = TradingGate()
        gate.update_mode(SystemMode.RECOVERING, RecoveryStage.READY)

        assert gate.allows(ActionType.QUERY) is True
        assert gate.allows(ActionType.CANCEL) is True
        assert gate.allows(ActionType.REDUCE_ONLY) is True
        assert gate.allows(ActionType.OPEN) is False
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/degradation/test_trading_gate.py -v`
Expected: FAIL with "cannot import name 'TradingGate'"

**Step 3: Create trading_gate.py**

```python
# backend/src/degradation/trading_gate.py
"""TradingGate - Unified gate for all trading operations.

All trading operations must pass through this gate:
- send_order(), amend_order(), cancel_order(), open_position()

The gate provides O(1) mode checks by maintaining local state that
is updated by the SystemStateService.

Usage:
    from src.degradation.trading_gate import get_trading_gate

    gate = get_trading_gate()
    if gate.allows(ActionType.SEND):
        await broker.send_order(order)
    else:
        raise TradingNotAllowedError(gate.get_rejection_reason())
"""

import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING

from src.degradation.models import ActionType, RecoveryStage, SystemMode

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class PermissionResult:
    """Result of a permission check."""

    allowed: bool
    warning: str | None = None
    rejection_reason: str | None = None


# Permission matrix: (mode, stage) -> allowed actions
# Stage is only relevant for RECOVERING mode
PERMISSION_MATRIX: dict[SystemMode, dict[ActionType, bool]] = {
    SystemMode.NORMAL: {
        ActionType.OPEN: True,
        ActionType.SEND: True,
        ActionType.AMEND: True,
        ActionType.CANCEL: True,
        ActionType.REDUCE_ONLY: True,
        ActionType.QUERY: True,
    },
    SystemMode.DEGRADED: {
        ActionType.OPEN: True,  # With restrictions
        ActionType.SEND: True,
        ActionType.AMEND: True,
        ActionType.CANCEL: True,
        ActionType.REDUCE_ONLY: True,
        ActionType.QUERY: True,
    },
    SystemMode.SAFE_MODE: {
        ActionType.OPEN: False,
        ActionType.SEND: False,
        ActionType.AMEND: False,
        ActionType.CANCEL: True,  # Best-effort
        ActionType.REDUCE_ONLY: True,
        ActionType.QUERY: True,
    },
    SystemMode.SAFE_MODE_DISCONNECTED: {
        ActionType.OPEN: False,
        ActionType.SEND: False,
        ActionType.AMEND: False,
        ActionType.CANCEL: False,  # No broker connection
        ActionType.REDUCE_ONLY: False,
        ActionType.QUERY: True,  # Local cache only
    },
    SystemMode.HALT: {
        ActionType.OPEN: False,
        ActionType.SEND: False,
        ActionType.AMEND: False,
        ActionType.CANCEL: False,
        ActionType.REDUCE_ONLY: False,
        ActionType.QUERY: True,
    },
}

# Recovery stage permissions
RECOVERY_PERMISSIONS: dict[RecoveryStage, dict[ActionType, bool]] = {
    RecoveryStage.CONNECT_BROKER: {
        ActionType.OPEN: False,
        ActionType.SEND: False,
        ActionType.AMEND: False,
        ActionType.CANCEL: False,
        ActionType.REDUCE_ONLY: False,
        ActionType.QUERY: True,
    },
    RecoveryStage.CATCHUP_MARKETDATA: {
        ActionType.OPEN: False,
        ActionType.SEND: False,
        ActionType.AMEND: False,
        ActionType.CANCEL: False,
        ActionType.REDUCE_ONLY: False,
        ActionType.QUERY: True,
    },
    RecoveryStage.VERIFY_RISK: {
        ActionType.OPEN: False,
        ActionType.SEND: False,
        ActionType.AMEND: False,
        ActionType.CANCEL: True,  # If broker available
        ActionType.REDUCE_ONLY: False,
        ActionType.QUERY: True,
    },
    RecoveryStage.READY: {
        ActionType.OPEN: False,
        ActionType.SEND: False,
        ActionType.AMEND: False,
        ActionType.CANCEL: True,
        ActionType.REDUCE_ONLY: True,
        ActionType.QUERY: True,
    },
}


class TradingGate:
    """Unified gate for trading operations.

    This class maintains the current system mode and provides O(1) permission
    checks for trading actions. Mode is updated by SystemStateService.
    """

    def __init__(self) -> None:
        """Initialize TradingGate with default RECOVERING mode (cold start)."""
        self._mode = SystemMode.RECOVERING
        self._stage: RecoveryStage | None = RecoveryStage.CONNECT_BROKER

    @property
    def mode(self) -> SystemMode:
        """Current system mode."""
        return self._mode

    @property
    def stage(self) -> RecoveryStage | None:
        """Current recovery stage (only set during RECOVERING)."""
        return self._stage

    def update_mode(
        self,
        mode: SystemMode,
        stage: RecoveryStage | None = None,
    ) -> None:
        """Update the current mode and stage.

        Called by SystemStateService when mode changes.

        Args:
            mode: New system mode.
            stage: Recovery stage (only for RECOVERING mode).
        """
        self._mode = mode
        self._stage = stage if mode == SystemMode.RECOVERING else None
        logger.info("TradingGate updated: mode=%s, stage=%s", mode, stage)

    def allows(self, action: ActionType) -> bool:
        """Check if action is allowed.

        Args:
            action: The action to check.

        Returns:
            True if action is allowed, False otherwise.
        """
        return self.check_permission(action).allowed

    def allows_with_warning(self, action: ActionType) -> tuple[bool, str | None]:
        """Check if action is allowed with optional warning.

        Args:
            action: The action to check.

        Returns:
            Tuple of (allowed, warning_message).
        """
        result = self.check_permission(action)
        return result.allowed, result.warning or result.rejection_reason

    def check_permission(self, action: ActionType) -> PermissionResult:
        """Full permission check with detailed result.

        Args:
            action: The action to check.

        Returns:
            PermissionResult with allowed, warning, and rejection_reason.
        """
        if self._mode == SystemMode.RECOVERING:
            return self._check_recovery_permission(action)

        permissions = PERMISSION_MATRIX.get(self._mode, {})
        allowed = permissions.get(action, False)

        # Add warnings for specific scenarios
        warning = None
        rejection_reason = None

        if self._mode == SystemMode.DEGRADED and action == ActionType.OPEN:
            warning = "DEGRADED: Open positions are restricted"

        elif self._mode == SystemMode.SAFE_MODE:
            if action == ActionType.CANCEL:
                warning = "SAFE_MODE: Cancel is best-effort, may fail"
            elif not allowed:
                rejection_reason = "SAFE_MODE: Only cancel, reduce-only, and query allowed"

        elif self._mode == SystemMode.SAFE_MODE_DISCONNECTED:
            if action == ActionType.CANCEL:
                rejection_reason = "DISCONNECTED: Cancel not possible, no broker connection"
            elif action == ActionType.QUERY:
                warning = "DISCONNECTED: Query returns cached data only"
            elif not allowed:
                rejection_reason = "DISCONNECTED: Only cached query allowed"

        elif self._mode == SystemMode.HALT:
            if not allowed:
                rejection_reason = "HALT: All operations suspended, manual intervention required"

        return PermissionResult(
            allowed=allowed,
            warning=warning,
            rejection_reason=rejection_reason,
        )

    def _check_recovery_permission(self, action: ActionType) -> PermissionResult:
        """Check permission during recovery mode."""
        if self._stage is None:
            return PermissionResult(
                allowed=action == ActionType.QUERY,
                rejection_reason="RECOVERING: Recovery stage unknown",
            )

        permissions = RECOVERY_PERMISSIONS.get(self._stage, {})
        allowed = permissions.get(action, False)

        rejection_reason = None
        if not allowed:
            rejection_reason = f"RECOVERING({self._stage.value}): Action not allowed"

        return PermissionResult(
            allowed=allowed,
            rejection_reason=rejection_reason,
        )

    def get_rejection_reason(self, action: ActionType) -> str:
        """Get rejection reason for an action.

        Args:
            action: The action that was rejected.

        Returns:
            Human-readable rejection reason.
        """
        result = self.check_permission(action)
        return result.rejection_reason or f"Action {action.value} not allowed in {self._mode.value}"


# Global gate instance
_trading_gate: TradingGate | None = None


def init_trading_gate() -> TradingGate:
    """Initialize global trading gate.

    Returns:
        The initialized TradingGate instance.
    """
    global _trading_gate
    _trading_gate = TradingGate()
    logger.info("TradingGate initialized")
    return _trading_gate


def get_trading_gate() -> TradingGate | None:
    """Get the global trading gate instance.

    Returns:
        The TradingGate, or None if not initialized.
    """
    return _trading_gate
```

**Step 4: Update __init__.py**

Add exports:
```python
from src.degradation.trading_gate import TradingGate, get_trading_gate, init_trading_gate
```

**Step 5: Run tests**

Run: `cd backend && pytest tests/degradation/test_trading_gate.py -v`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add backend/src/degradation/trading_gate.py backend/tests/degradation/test_trading_gate.py backend/src/degradation/__init__.py
git commit -m "feat(degradation): add TradingGate with permission matrix

- O(1) permission checks for all trading actions
- Mode-based permission matrix (NORMAL, DEGRADED, SAFE_MODE, HALT)
- Recovery stage permissions (CONNECT_BROKER, CATCHUP_MARKETDATA, etc.)
- SAFE_MODE cancel with best-effort warning
- SAFE_MODE_DISCONNECTED query returns cached only"
```

---

## Task 5: Backend SystemStateService

**Files:**
- Create: `backend/src/degradation/state_service.py`
- Test: `backend/tests/degradation/test_state_service.py`

**Step 1: Create test file**

```python
# backend/tests/degradation/test_state_service.py
"""Tests for SystemStateService."""

import asyncio
import time
from datetime import datetime, timezone
from unittest.mock import AsyncMock, MagicMock

import pytest

from src.degradation.config import DegradationConfig
from src.degradation.event_bus import EventBus
from src.degradation.models import (
    ComponentSource,
    EventType,
    MODE_PRIORITY,
    ReasonCode,
    RecoveryStage,
    Severity,
    SystemEvent,
    SystemLevel,
    SystemMode,
    create_event,
)
from src.degradation.state_service import SystemStateService
from src.degradation.trading_gate import TradingGate


class TestSystemStateServiceInit:
    """Tests for SystemStateService initialization."""

    def test_cold_start_is_recovering(self):
        """System should start in RECOVERING mode (cold start)."""
        config = DegradationConfig()
        gate = TradingGate()
        bus = EventBus(config)

        service = SystemStateService(config, gate, bus)

        assert service.mode == SystemMode.RECOVERING
        assert service.stage == RecoveryStage.CONNECT_BROKER


class TestSystemStateServiceTransition:
    """Tests for mode transitions."""

    @pytest.mark.asyncio
    async def test_transition_to_safe_mode(self):
        """Broker disconnect should transition to SAFE_MODE_DISCONNECTED."""
        config = DegradationConfig()
        gate = TradingGate()
        bus = EventBus(config)
        service = SystemStateService(config, gate, bus)

        event = create_event(
            event_type=EventType.FAIL_CRIT,
            source=ComponentSource.BROKER,
            severity=Severity.CRITICAL,
            reason_code=ReasonCode.BROKER_DISCONNECT,
        )

        await service.handle_event(event)

        assert service.mode == SystemMode.SAFE_MODE_DISCONNECTED
        assert gate.mode == SystemMode.SAFE_MODE_DISCONNECTED


class TestConflictResolution:
    """Tests for multi-event conflict resolution."""

    @pytest.mark.asyncio
    async def test_takes_most_severe(self):
        """Multiple events should result in most severe mode."""
        config = DegradationConfig()
        gate = TradingGate()
        bus = EventBus(config)
        service = SystemStateService(config, gate, bus)

        # Fire multiple events
        events = [
            create_event(
                EventType.FAIL_SUPP,
                ComponentSource.ALERTS,
                Severity.WARNING,
                ReasonCode.ALERTS_CHANNEL_DOWN,  # -> DEGRADED
            ),
            create_event(
                EventType.FAIL_CRIT,
                ComponentSource.MARKET_DATA,
                Severity.CRITICAL,
                ReasonCode.MD_STALE,  # -> SAFE_MODE
            ),
        ]

        for event in events:
            await service.handle_event(event)

        # Should be SAFE_MODE (most severe)
        assert service.mode == SystemMode.SAFE_MODE

    @pytest.mark.asyncio
    async def test_cannot_downgrade_without_recovery(self):
        """Cannot transition to less severe mode without full recovery."""
        config = DegradationConfig()
        gate = TradingGate()
        bus = EventBus(config)
        service = SystemStateService(config, gate, bus)

        # Go to SAFE_MODE
        await service.handle_event(
            create_event(
                EventType.FAIL_CRIT,
                ComponentSource.MARKET_DATA,
                Severity.CRITICAL,
                ReasonCode.MD_STALE,
            )
        )
        assert service.mode == SystemMode.SAFE_MODE

        # Try to go to DEGRADED (less severe) - should be rejected
        await service.handle_event(
            create_event(
                EventType.RECOVERED,
                ComponentSource.MARKET_DATA,
                Severity.INFO,
                ReasonCode.ALL_HEALTHY,
            )
        )
        # Should still be in SAFE_MODE, waiting for full recovery
        assert service.mode in (SystemMode.SAFE_MODE, SystemMode.RECOVERING)


class TestForceOverride:
    """Tests for force override functionality."""

    @pytest.mark.asyncio
    async def test_force_mode_with_ttl(self):
        """Force mode should override automatic logic."""
        config = DegradationConfig()
        gate = TradingGate()
        bus = EventBus(config)
        service = SystemStateService(config, gate, bus)

        await service.force_mode(
            mode=SystemMode.NORMAL,
            ttl_seconds=300,
            operator_id="admin",
            reason="Emergency override",
        )

        assert service.mode == SystemMode.NORMAL
        assert service.is_force_override is True

    @pytest.mark.asyncio
    async def test_force_override_blocks_auto_transitions(self):
        """During force override, automatic transitions should be blocked."""
        config = DegradationConfig()
        gate = TradingGate()
        bus = EventBus(config)
        service = SystemStateService(config, gate, bus)

        await service.force_mode(
            mode=SystemMode.NORMAL,
            ttl_seconds=300,
            operator_id="admin",
            reason="Testing",
        )

        # Try automatic transition
        await service.handle_event(
            create_event(
                EventType.FAIL_SUPP,
                ComponentSource.ALERTS,
                Severity.WARNING,
                ReasonCode.ALERTS_CHANNEL_DOWN,
            )
        )

        # Should still be NORMAL due to override
        assert service.mode == SystemMode.NORMAL
```

**Step 2: Run test to verify it fails**

Run: `cd backend && pytest tests/degradation/test_state_service.py -v`
Expected: FAIL with "cannot import name 'SystemStateService'"

**Step 3: Create state_service.py**

```python
# backend/src/degradation/state_service.py
"""SystemStateService - Central state management.

The SystemStateService is the SINGLE SOURCE OF TRUTH for system mode.
Only this service can modify the system state. All other components
must query this service and react to its events.

Key responsibilities:
- Maintain SystemMode + SystemLevel state machine
- Process events and determine mode transitions via Decision Matrix
- Handle conflict resolution (take most severe mode)
- Manage force override with TTL
- Broadcast mode changes to TradingGate and EventBus

Usage:
    from src.degradation.state_service import get_system_state

    state = get_system_state()
    if state.mode == SystemMode.NORMAL:
        # Full functionality
"""

import asyncio
import logging
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import TYPE_CHECKING

from src.degradation.config import DegradationConfig
from src.degradation.event_bus import EventBus
from src.degradation.models import (
    ActionType,
    ComponentSource,
    ComponentStatus,
    EventType,
    MODE_PRIORITY,
    ModeTransition,
    ReasonCode,
    RecoveryStage,
    Severity,
    SystemEvent,
    SystemLevel,
    SystemMode,
    create_event,
)
from src.degradation.trading_gate import TradingGate

logger = logging.getLogger(__name__)


# Decision Matrix: ReasonCode -> target SystemMode
DECISION_MATRIX: dict[ReasonCode, SystemMode] = {
    # Broker
    ReasonCode.BROKER_DISCONNECT: SystemMode.SAFE_MODE_DISCONNECTED,
    ReasonCode.BROKER_RECONNECTED: SystemMode.RECOVERING,
    ReasonCode.BROKER_REPORT_MISMATCH: SystemMode.HALT,
    # Market Data
    ReasonCode.MD_STALE: SystemMode.SAFE_MODE,
    ReasonCode.MD_QUALITY_DEGRADED: SystemMode.DEGRADED,
    # Risk
    ReasonCode.RISK_TIMEOUT: SystemMode.SAFE_MODE,
    ReasonCode.RISK_BREACH_HARD: SystemMode.HALT,
    # Position
    ReasonCode.POSITION_TRUTH_UNKNOWN: SystemMode.HALT,
    # Database
    ReasonCode.DB_WRITE_FAIL_BUFFERED: SystemMode.DEGRADED,
    ReasonCode.DB_BUFFER_OVERFLOW: SystemMode.SAFE_MODE,
    # Alerts
    ReasonCode.ALERTS_CHANNEL_DOWN: SystemMode.DEGRADED,
    # Recovery
    ReasonCode.RECOVERY_FAILED: SystemMode.HALT,
    ReasonCode.RECOVERY_COMPLETE: SystemMode.NORMAL,
    # System
    ReasonCode.ALL_HEALTHY: SystemMode.NORMAL,
    ReasonCode.COLD_START: SystemMode.RECOVERING,
    ReasonCode.FORCE_OVERRIDE: SystemMode.NORMAL,  # Determined by force_mode()
}


@dataclass
class ForceOverrideState:
    """State for force override."""

    active: bool = False
    mode: SystemMode | None = None
    operator_id: str | None = None
    reason: str | None = None
    expires_at_mono: float | None = None


class SystemStateService:
    """Central state management service.

    SINGLE WRITER: Only this service modifies system state.
    """

    def __init__(
        self,
        config: DegradationConfig,
        trading_gate: TradingGate,
        event_bus: EventBus,
    ) -> None:
        """Initialize SystemStateService.

        Args:
            config: Degradation configuration.
            trading_gate: TradingGate to update on mode changes.
            event_bus: EventBus for publishing mode change events.
        """
        self._config = config
        self._gate = trading_gate
        self._bus = event_bus

        # State
        self._mode = SystemMode.RECOVERING
        self._stage: RecoveryStage | None = RecoveryStage.CONNECT_BROKER
        self._level = SystemLevel.HEALTHY
        self._last_transition: ModeTransition | None = None

        # Force override
        self._override = ForceOverrideState()

        # Component status tracking
        self._component_status: dict[ComponentSource, ComponentStatus] = {}

        # Dwell time tracking
        self._mode_entered_mono: float = time.monotonic()

        # Initialize gate
        self._gate.update_mode(self._mode, self._stage)

        # Set up emergency callback on event bus
        self._bus.set_emergency_callback(self._on_emergency_degrade)

        logger.info(
            "SystemStateService initialized: mode=%s, stage=%s",
            self._mode,
            self._stage,
        )

    @property
    def mode(self) -> SystemMode:
        """Current system mode."""
        return self._mode

    @property
    def stage(self) -> RecoveryStage | None:
        """Current recovery stage (only during RECOVERING)."""
        return self._stage

    @property
    def level(self) -> SystemLevel:
        """Current system level (HEALTHY, UNSTABLE, TRIPPED)."""
        return self._level

    @property
    def is_force_override(self) -> bool:
        """Whether force override is active."""
        if not self._override.active:
            return False
        # Check expiry
        if self._override.expires_at_mono is not None:
            if time.monotonic() > self._override.expires_at_mono:
                self._override.active = False
                return False
        return True

    async def handle_event(self, event: SystemEvent) -> None:
        """Handle a system event and potentially transition mode.

        This is the main entry point for event processing.

        Args:
            event: The system event to process.
        """
        # Check force override
        if self.is_force_override:
            logger.info(
                "Ignoring event %s during force override",
                event.reason_code,
            )
            return

        # Get target mode from decision matrix
        target_mode = DECISION_MATRIX.get(event.reason_code)
        if target_mode is None:
            logger.warning("Unknown reason code: %s", event.reason_code)
            return

        # Update component status
        self._update_component_status(event)

        # Check if transition is allowed
        if self._can_transition(target_mode):
            await self._transition_to(target_mode, event)

    async def force_mode(
        self,
        mode: SystemMode,
        ttl_seconds: int,
        operator_id: str,
        reason: str,
    ) -> None:
        """Force system into specific mode, overriding automatic logic.

        Args:
            mode: Target mode.
            ttl_seconds: Override duration.
            operator_id: Who initiated the override.
            reason: Human-readable reason.
        """
        self._override.active = True
        self._override.mode = mode
        self._override.operator_id = operator_id
        self._override.reason = reason
        self._override.expires_at_mono = time.monotonic() + ttl_seconds

        # Create synthetic event for transition
        event = create_event(
            event_type=EventType.RECOVERED,
            source=ComponentSource.SYSTEM,
            severity=Severity.WARNING,
            reason_code=ReasonCode.FORCE_OVERRIDE,
            details={
                "operator_id": operator_id,
                "reason": reason,
                "ttl_seconds": ttl_seconds,
            },
        )

        await self._transition_to(mode, event)

        logger.warning(
            "Force override activated: mode=%s, ttl=%ds, operator=%s, reason=%s",
            mode,
            ttl_seconds,
            operator_id,
            reason,
        )

    def _can_transition(self, target_mode: SystemMode) -> bool:
        """Check if transition to target mode is allowed.

        Rules:
        - Can always escalate to more severe mode
        - Can only de-escalate through proper recovery
        """
        current_priority = MODE_PRIORITY[self._mode]
        target_priority = MODE_PRIORITY[target_mode]

        if target_priority >= current_priority:
            return True

        # De-escalation requires recovery conditions
        if target_mode == SystemMode.NORMAL:
            return self._recovery_conditions_met()

        return False

    def _recovery_conditions_met(self) -> bool:
        """Check if conditions for recovery to NORMAL are met."""
        # Check minimum dwell time
        elapsed = time.monotonic() - self._mode_entered_mono
        if elapsed < self._config.recovery_stable_seconds:
            return False

        # All components should be healthy
        for status in self._component_status.values():
            if status.level != SystemLevel.HEALTHY:
                return False

        return True

    async def _transition_to(
        self,
        target_mode: SystemMode,
        event: SystemEvent,
    ) -> None:
        """Execute mode transition.

        Args:
            target_mode: The mode to transition to.
            event: The event that triggered the transition.
        """
        old_mode = self._mode
        self._mode = target_mode
        self._mode_entered_mono = time.monotonic()

        # Update stage for RECOVERING
        if target_mode == SystemMode.RECOVERING:
            self._stage = RecoveryStage.CONNECT_BROKER
        else:
            self._stage = None

        # Update trading gate
        self._gate.update_mode(self._mode, self._stage)

        # Record transition
        self._last_transition = ModeTransition(
            from_mode=old_mode,
            to_mode=target_mode,
            reason_code=event.reason_code,
            source=event.source,
            timestamp_wall=datetime.now(tz=timezone.utc),
            timestamp_mono=time.monotonic(),
        )

        logger.warning(
            "Mode transition: %s -> %s (reason: %s, source: %s)",
            old_mode.value,
            target_mode.value,
            event.reason_code.value,
            event.source.value,
        )

        # TODO: Emit alert and audit events (integrate with Slice 3.1/3.2)

    def _update_component_status(self, event: SystemEvent) -> None:
        """Update component status based on event."""
        source = event.source
        current = self._component_status.get(source)

        if event.event_type in (EventType.FAIL_CRIT, EventType.FAIL_SUPP):
            if current is None:
                current = ComponentStatus(
                    source=source,
                    level=SystemLevel.UNSTABLE,
                    last_event=event,
                    last_update_mono=event.event_time_mono,
                    consecutive_failures=1,
                    unstable_since_mono=event.event_time_mono,
                )
            else:
                current = ComponentStatus(
                    source=source,
                    level=SystemLevel.TRIPPED if current.consecutive_failures >= self._config.fail_threshold_count else SystemLevel.UNSTABLE,
                    last_event=event,
                    last_update_mono=event.event_time_mono,
                    consecutive_failures=current.consecutive_failures + 1,
                    unstable_since_mono=current.unstable_since_mono or event.event_time_mono,
                )
        elif event.event_type == EventType.RECOVERED:
            current = ComponentStatus(
                source=source,
                level=SystemLevel.HEALTHY,
                last_event=event,
                last_update_mono=event.event_time_mono,
                consecutive_failures=0,
                unstable_since_mono=None,
            )

        if current:
            self._component_status[source] = current

    def _on_emergency_degrade(self, event: SystemEvent) -> None:
        """Handle emergency degrade from EventBus.

        Called when a critical event couldn't be queued. This ensures
        we still degrade even if the event bus is overwhelmed.
        """
        logger.critical(
            "Emergency degrade from EventBus: %s",
            event.reason_code,
        )
        # Synchronously update mode (bypass normal async flow)
        target_mode = DECISION_MATRIX.get(event.reason_code, SystemMode.SAFE_MODE)
        if MODE_PRIORITY[target_mode] > MODE_PRIORITY[self._mode]:
            self._mode = target_mode
            self._gate.update_mode(self._mode, self._stage)

    def update_recovery_stage(self, stage: RecoveryStage) -> None:
        """Update recovery stage.

        Called by RecoveryOrchestrator as it progresses through stages.

        Args:
            stage: The new recovery stage.
        """
        if self._mode != SystemMode.RECOVERING:
            logger.warning("Cannot update stage when not in RECOVERING mode")
            return

        self._stage = stage
        self._gate.update_mode(self._mode, self._stage)
        logger.info("Recovery stage updated: %s", stage)


# Global instance
_state_service: SystemStateService | None = None


def init_system_state(
    config: DegradationConfig,
    trading_gate: TradingGate,
    event_bus: EventBus,
) -> SystemStateService:
    """Initialize global system state service.

    Args:
        config: Degradation configuration.
        trading_gate: Trading gate instance.
        event_bus: Event bus instance.

    Returns:
        The initialized SystemStateService.
    """
    global _state_service
    _state_service = SystemStateService(config, trading_gate, event_bus)
    return _state_service


def get_system_state() -> SystemStateService | None:
    """Get the global system state service.

    Returns:
        The SystemStateService, or None if not initialized.
    """
    return _state_service
```

**Step 4: Update __init__.py**

Add exports:
```python
from src.degradation.state_service import (
    SystemStateService,
    get_system_state,
    init_system_state,
)
```

**Step 5: Run tests**

Run: `cd backend && pytest tests/degradation/test_state_service.py -v`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add backend/src/degradation/state_service.py backend/tests/degradation/test_state_service.py backend/src/degradation/__init__.py
git commit -m "feat(degradation): add SystemStateService with Decision Matrix

- Single source of truth for system mode
- Decision Matrix for mode transitions
- Conflict resolution (take most severe)
- Force override with TTL
- Component status tracking with hysteresis
- Cold start in RECOVERING mode"
```

---

## Task 6: Backend Circuit Breakers

**Files:**
- Create: `backend/src/degradation/breakers.py`
- Test: `backend/tests/degradation/test_breakers.py`

This task implements the CircuitBreaker base class and component-specific breakers for Broker, MarketData, Risk, and DB.

**Step 1-6:** Follow TDD pattern (create test, verify fail, implement, verify pass, commit)

See full implementation in design document section 2.6.

---

## Task 7: Backend Recovery Orchestrator

**Files:**
- Create: `backend/src/degradation/recovery.py`
- Test: `backend/tests/degradation/test_recovery.py`

This task implements the RecoveryOrchestrator with recovery_run_id idempotency.

**Step 1-6:** Follow TDD pattern

See full implementation in design document section 5.

---

## Task 8: Backend DB Buffer with WAL

**Files:**
- Create: `backend/src/degradation/db_buffer.py`
- Test: `backend/tests/degradation/test_db_buffer.py`

This task implements the DBBuffer with WAL persistence.

**Step 1-6:** Follow TDD pattern

See full implementation in design document section 6.

---

## Task 9: Backend Cache with Staleness

**Files:**
- Create: `backend/src/degradation/cache.py`
- Test: `backend/tests/degradation/test_cache.py`

This task implements CachedData with staleness tracking for SAFE_MODE_DISCONNECTED.

---

## Task 10: Backend Probes

**Files:**
- Create: `backend/src/degradation/probes.py`
- Test: `backend/tests/degradation/test_probes.py`

This task implements ComponentProbe protocol and implementations.

---

## Task 11: Backend Setup Module

**Files:**
- Create: `backend/src/degradation/setup.py`
- Test: `backend/tests/degradation/test_setup.py`

**Step 1: Create test file**

```python
# backend/tests/degradation/test_setup.py
"""Tests for degradation setup."""

import pytest

from src.degradation.setup import (
    get_event_bus,
    get_system_state,
    get_trading_gate,
    init_degradation,
)


class TestDegradationSetup:
    """Tests for degradation initialization."""

    @pytest.mark.asyncio
    async def test_init_creates_all_services(self):
        """init_degradation should create all required services."""
        services = await init_degradation()

        assert services.state_service is not None
        assert services.trading_gate is not None
        assert services.event_bus is not None

    @pytest.mark.asyncio
    async def test_getters_return_initialized_services(self):
        """Global getters should return initialized services."""
        await init_degradation()

        assert get_system_state() is not None
        assert get_trading_gate() is not None
        assert get_event_bus() is not None

    @pytest.mark.asyncio
    async def test_cold_start_mode(self):
        """System should start in RECOVERING mode."""
        from src.degradation.models import SystemMode

        await init_degradation()
        state = get_system_state()

        assert state.mode == SystemMode.RECOVERING
```

**Step 2-6:** Follow TDD pattern

```python
# backend/src/degradation/setup.py
"""Degradation system initialization.

This module provides functions to initialize the graceful degradation system.
Call init_degradation() during application startup.

Usage:
    from src.degradation.setup import init_degradation, get_system_state

    # During startup:
    await init_degradation()

    # Later, anywhere in app:
    state = get_system_state()
"""

import logging
from dataclasses import dataclass

from src.degradation.config import DegradationConfig, get_config
from src.degradation.event_bus import EventBus
from src.degradation.state_service import SystemStateService
from src.degradation.trading_gate import TradingGate

logger = logging.getLogger(__name__)

# Global instances
_state_service: SystemStateService | None = None
_trading_gate: TradingGate | None = None
_event_bus: EventBus | None = None


@dataclass
class DegradationServices:
    """Container for all degradation services."""

    state_service: SystemStateService
    trading_gate: TradingGate
    event_bus: EventBus


async def init_degradation(
    config: DegradationConfig | None = None,
) -> DegradationServices:
    """Initialize the degradation system.

    Creates and wires all degradation components:
    - TradingGate
    - EventBus
    - SystemStateService

    Args:
        config: Optional config override (uses default if None).

    Returns:
        Container with all initialized services.
    """
    global _state_service, _trading_gate, _event_bus

    config = config or get_config()

    # Create components
    _trading_gate = TradingGate()
    _event_bus = EventBus(config)
    _state_service = SystemStateService(config, _trading_gate, _event_bus)

    # Start event bus
    await _event_bus.start()

    logger.info("Degradation system initialized")

    return DegradationServices(
        state_service=_state_service,
        trading_gate=_trading_gate,
        event_bus=_event_bus,
    )


async def shutdown_degradation() -> None:
    """Shutdown the degradation system."""
    global _event_bus
    if _event_bus:
        await _event_bus.stop()
    logger.info("Degradation system shutdown")


def get_system_state() -> SystemStateService | None:
    """Get the global system state service."""
    return _state_service


def get_trading_gate() -> TradingGate | None:
    """Get the global trading gate."""
    return _trading_gate


def get_event_bus() -> EventBus | None:
    """Get the global event bus."""
    return _event_bus
```

---

## Task 12: Backend API Endpoints

**Files:**
- Create: `backend/src/api/degradation.py`
- Test: `backend/tests/api/test_degradation.py`

**Step 1: Create test file**

```python
# backend/tests/api/test_degradation.py
"""Tests for degradation API endpoints."""

import pytest
from httpx import AsyncClient


class TestDegradationAPI:
    """Tests for degradation API."""

    @pytest.mark.asyncio
    async def test_get_status(self, client: AsyncClient):
        """GET /api/degradation/status should return current state."""
        response = await client.get("/api/degradation/status")
        assert response.status_code == 200
        data = response.json()
        assert "mode" in data
        assert "stage" in data
        assert "level" in data

    @pytest.mark.asyncio
    async def test_force_mode(self, client: AsyncClient):
        """POST /api/degradation/force should set mode with TTL."""
        response = await client.post(
            "/api/degradation/force",
            json={
                "mode": "normal",
                "ttl_seconds": 300,
                "operator_id": "test-admin",
                "reason": "Testing force override",
            },
        )
        assert response.status_code == 200
        data = response.json()
        assert data["mode"] == "normal"
        assert data["is_override"] is True
```

**Step 2-6:** Follow TDD pattern

```python
# backend/src/api/degradation.py
"""Degradation API endpoints."""

from datetime import datetime
from typing import Any

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel

from src.degradation.models import RecoveryStage, SystemLevel, SystemMode
from src.degradation.setup import get_system_state, get_trading_gate


class SystemStatusResponse(BaseModel):
    """Response model for system status."""

    mode: str
    stage: str | None
    level: str
    is_override: bool
    override_expires_at: datetime | None
    last_transition: dict | None


class ForceOverrideRequest(BaseModel):
    """Request model for force override."""

    mode: str
    ttl_seconds: int
    operator_id: str
    reason: str


class ForceOverrideResponse(BaseModel):
    """Response model for force override."""

    mode: str
    is_override: bool
    expires_at: datetime


class TradingPermissionsResponse(BaseModel):
    """Response model for trading permissions."""

    mode: str
    permissions: dict[str, bool]


router = APIRouter(prefix="/api/degradation", tags=["degradation"])


@router.get("/status", response_model=SystemStatusResponse)
async def get_status() -> SystemStatusResponse:
    """Get current system status."""
    state = get_system_state()
    if state is None:
        raise HTTPException(status_code=503, detail="Degradation system not initialized")

    return SystemStatusResponse(
        mode=state.mode.value,
        stage=state.stage.value if state.stage else None,
        level=state.level.value,
        is_override=state.is_force_override,
        override_expires_at=None,  # TODO: Add expiry tracking
        last_transition=None,  # TODO: Add transition history
    )


@router.post("/force", response_model=ForceOverrideResponse)
async def force_override(request: ForceOverrideRequest) -> ForceOverrideResponse:
    """Force system into specific mode."""
    state = get_system_state()
    if state is None:
        raise HTTPException(status_code=503, detail="Degradation system not initialized")

    try:
        mode = SystemMode(request.mode)
    except ValueError:
        raise HTTPException(status_code=400, detail=f"Invalid mode: {request.mode}")

    await state.force_mode(
        mode=mode,
        ttl_seconds=request.ttl_seconds,
        operator_id=request.operator_id,
        reason=request.reason,
    )

    from datetime import timezone
    import time

    expires_at = datetime.fromtimestamp(
        time.time() + request.ttl_seconds,
        tz=timezone.utc,
    )

    return ForceOverrideResponse(
        mode=mode.value,
        is_override=True,
        expires_at=expires_at,
    )


@router.get("/permissions", response_model=TradingPermissionsResponse)
async def get_permissions() -> TradingPermissionsResponse:
    """Get current trading permissions."""
    gate = get_trading_gate()
    if gate is None:
        raise HTTPException(status_code=503, detail="Trading gate not initialized")

    from src.degradation.models import ActionType

    permissions = {
        action.value: gate.allows(action)
        for action in ActionType
    }

    return TradingPermissionsResponse(
        mode=gate.mode.value,
        permissions=permissions,
    )
```

---

## Task 13: Database Migration

**Files:**
- Create: `backend/alembic/versions/006_degradation.py`

**Step 1: Create migration**

```python
# backend/alembic/versions/006_degradation.py
"""Create degradation state tables.

Revision ID: 006_degradation
Revises: 005_audit_logs
Create Date: 2026-01-26
"""

import sqlalchemy as sa
from alembic import op
from sqlalchemy.dialects.postgresql import JSONB, UUID

revision = "006_degradation"
down_revision = "005_audit_logs"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Create mode_transitions table for history
    op.create_table(
        "mode_transitions",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("timestamp", sa.TIMESTAMP(timezone=True), nullable=False),
        sa.Column("from_mode", sa.VARCHAR(30), nullable=False),
        sa.Column("to_mode", sa.VARCHAR(30), nullable=False),
        sa.Column("reason_code", sa.VARCHAR(50), nullable=False),
        sa.Column("source", sa.VARCHAR(30), nullable=False),
        sa.Column("operator_id", sa.VARCHAR(100), nullable=True),
        sa.Column("override_ttl", sa.INTEGER, nullable=True),
        sa.Column("details", JSONB, nullable=True),
        # CHECK constraints
        sa.CheckConstraint(
            "from_mode IN ('normal', 'degraded', 'safe_mode', 'safe_mode_disconnected', 'halt', 'recovering')",
            name="ck_mode_transitions_from_mode",
        ),
        sa.CheckConstraint(
            "to_mode IN ('normal', 'degraded', 'safe_mode', 'safe_mode_disconnected', 'halt', 'recovering')",
            name="ck_mode_transitions_to_mode",
        ),
    )

    # Create index for querying recent transitions
    op.create_index(
        "idx_mode_transitions_timestamp",
        "mode_transitions",
        [sa.text("timestamp DESC")],
    )

    # Create db_buffer_wal table for WAL entries
    op.create_table(
        "db_buffer_wal",
        sa.Column("id", sa.BIGINT, primary_key=True, autoincrement=True),
        sa.Column("idempotent_key", sa.VARCHAR(200), nullable=False, unique=True),
        sa.Column("resource_type", sa.VARCHAR(50), nullable=False),
        sa.Column("resource_id", sa.VARCHAR(100), nullable=False),
        sa.Column("old_state", JSONB, nullable=True),
        sa.Column("new_state", JSONB, nullable=False),
        sa.Column("created_at", sa.TIMESTAMP(timezone=True), nullable=False, server_default=sa.text("NOW()")),
        sa.Column("replayed_at", sa.TIMESTAMP(timezone=True), nullable=True),
    )


def downgrade() -> None:
    op.drop_table("db_buffer_wal")
    op.drop_index("idx_mode_transitions_timestamp", table_name="mode_transitions")
    op.drop_table("mode_transitions")
```

**Step 2: Run migration**

Run: `cd backend && alembic upgrade head`
Expected: Migration applies successfully

**Step 3: Commit**

```bash
git add backend/alembic/versions/006_degradation.py
git commit -m "feat(degradation): add database migration

- mode_transitions table for transition history
- db_buffer_wal table for WAL entries
- CHECK constraints for mode values"
```

---

## Task 14: Frontend Types

**Files:**
- Modify: `frontend/src/types/index.ts`

**Step 1: Add degradation types**

```typescript
// Add to frontend/src/types/index.ts

// Degradation types
export type SystemModeValue =
  | 'normal'
  | 'degraded'
  | 'safe_mode'
  | 'safe_mode_disconnected'
  | 'halt'
  | 'recovering';

export type SystemLevelValue = 'healthy' | 'unstable' | 'tripped';

export type RecoveryStageValue =
  | 'connect_broker'
  | 'catchup_marketdata'
  | 'verify_risk'
  | 'ready';

export interface SystemStatus {
  mode: SystemModeValue;
  stage: RecoveryStageValue | null;
  level: SystemLevelValue;
  is_override: boolean;
  override_expires_at: string | null;
  last_transition: ModeTransition | null;
}

export interface ModeTransition {
  from_mode: SystemModeValue;
  to_mode: SystemModeValue;
  reason_code: string;
  source: string;
  timestamp: string;
  operator_id: string | null;
}

export interface TradingPermissions {
  mode: SystemModeValue;
  permissions: {
    open: boolean;
    send: boolean;
    amend: boolean;
    cancel: boolean;
    reduce_only: boolean;
    query: boolean;
  };
}

export interface ForceOverrideRequest {
  mode: SystemModeValue;
  ttl_seconds: number;
  operator_id: string;
  reason: string;
}

export interface ForceOverrideResponse {
  mode: SystemModeValue;
  is_override: boolean;
  expires_at: string;
}
```

**Step 2: Commit**

```bash
git add frontend/src/types/index.ts
git commit -m "feat(frontend): add degradation types"
```

---

## Task 15: Frontend API Client

**Files:**
- Create: `frontend/src/api/degradation.ts`

```typescript
// frontend/src/api/degradation.ts
import { apiClient } from './client';
import type {
  ForceOverrideRequest,
  ForceOverrideResponse,
  SystemStatus,
  TradingPermissions,
} from '../types';

export async function fetchSystemStatus(): Promise<SystemStatus> {
  const response = await apiClient.get<SystemStatus>('/degradation/status');
  return response.data;
}

export async function fetchTradingPermissions(): Promise<TradingPermissions> {
  const response = await apiClient.get<TradingPermissions>('/degradation/permissions');
  return response.data;
}

export async function forceOverride(
  request: ForceOverrideRequest
): Promise<ForceOverrideResponse> {
  const response = await apiClient.post<ForceOverrideResponse>(
    '/degradation/force',
    request
  );
  return response.data;
}
```

---

## Task 16: Frontend Hooks

**Files:**
- Create: `frontend/src/hooks/useDegradation.ts`
- Modify: `frontend/src/hooks/index.ts`

```typescript
// frontend/src/hooks/useDegradation.ts
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import {
  fetchSystemStatus,
  fetchTradingPermissions,
  forceOverride,
} from '../api/degradation';
import type { ForceOverrideRequest } from '../types';

export function useSystemStatus(refetchInterval = 5000) {
  return useQuery({
    queryKey: ['systemStatus'],
    queryFn: fetchSystemStatus,
    refetchInterval,
  });
}

export function useTradingPermissions(refetchInterval = 5000) {
  return useQuery({
    queryKey: ['tradingPermissions'],
    queryFn: fetchTradingPermissions,
    refetchInterval,
  });
}

export function useForceOverride() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (request: ForceOverrideRequest) => forceOverride(request),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['systemStatus'] });
      queryClient.invalidateQueries({ queryKey: ['tradingPermissions'] });
    },
  });
}
```

---

## Task 17: Frontend SystemStatus Component

**Files:**
- Create: `frontend/src/components/SystemStatus.tsx`

```tsx
// frontend/src/components/SystemStatus.tsx
import React from 'react';
import type { SystemModeValue, SystemStatus as SystemStatusType } from '../types';

interface Props {
  status: SystemStatusType;
}

const MODE_COLORS: Record<SystemModeValue, string> = {
  normal: 'bg-green-500',
  degraded: 'bg-yellow-500',
  safe_mode: 'bg-orange-500',
  safe_mode_disconnected: 'bg-red-500',
  halt: 'bg-red-700',
  recovering: 'bg-blue-500',
};

const MODE_LABELS: Record<SystemModeValue, string> = {
  normal: 'Normal',
  degraded: 'Degraded',
  safe_mode: 'Safe Mode',
  safe_mode_disconnected: 'Safe Mode (Disconnected)',
  halt: 'HALT',
  recovering: 'Recovering',
};

export function SystemStatus({ status }: Props) {
  const colorClass = MODE_COLORS[status.mode] || 'bg-gray-500';
  const label = MODE_LABELS[status.mode] || status.mode;

  return (
    <div className="flex items-center gap-2">
      <span className={`inline-block w-3 h-3 rounded-full ${colorClass}`} />
      <span className="font-medium">{label}</span>
      {status.stage && (
        <span className="text-sm text-gray-500">({status.stage})</span>
      )}
      {status.is_override && (
        <span className="text-xs bg-yellow-200 text-yellow-800 px-2 py-0.5 rounded">
          Override Active
        </span>
      )}
    </div>
  );
}
```

---

## Task 18: Frontend RecoveryPanel Component

**Files:**
- Create: `frontend/src/components/RecoveryPanel.tsx`

```tsx
// frontend/src/components/RecoveryPanel.tsx
import React, { useState } from 'react';
import { useForceOverride, useSystemStatus } from '../hooks/useDegradation';
import type { SystemModeValue } from '../types';

export function RecoveryPanel() {
  const { data: status, isLoading } = useSystemStatus();
  const forceOverrideMutation = useForceOverride();

  const [selectedMode, setSelectedMode] = useState<SystemModeValue>('normal');
  const [ttlSeconds, setTtlSeconds] = useState(300);
  const [reason, setReason] = useState('');

  if (isLoading || !status) {
    return <div>Loading...</div>;
  }

  const handleForceOverride = async () => {
    if (!reason.trim()) {
      alert('Please provide a reason');
      return;
    }

    await forceOverrideMutation.mutateAsync({
      mode: selectedMode,
      ttl_seconds: ttlSeconds,
      operator_id: 'ui-user', // TODO: Get from auth
      reason,
    });
  };

  return (
    <div className="p-4 border rounded-lg">
      <h3 className="text-lg font-semibold mb-4">Recovery Controls</h3>

      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">Force Mode</label>
          <select
            value={selectedMode}
            onChange={(e) => setSelectedMode(e.target.value as SystemModeValue)}
            className="w-full border rounded px-3 py-2"
          >
            <option value="normal">Normal</option>
            <option value="degraded">Degraded</option>
            <option value="safe_mode">Safe Mode</option>
            <option value="halt">Halt</option>
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">TTL (seconds)</label>
          <input
            type="number"
            value={ttlSeconds}
            onChange={(e) => setTtlSeconds(parseInt(e.target.value, 10))}
            className="w-full border rounded px-3 py-2"
            min={60}
            max={3600}
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">Reason</label>
          <textarea
            value={reason}
            onChange={(e) => setReason(e.target.value)}
            className="w-full border rounded px-3 py-2"
            rows={2}
            placeholder="Reason for override..."
          />
        </div>

        <button
          onClick={handleForceOverride}
          disabled={forceOverrideMutation.isPending}
          className="w-full bg-orange-500 text-white py-2 rounded hover:bg-orange-600 disabled:opacity-50"
        >
          {forceOverrideMutation.isPending ? 'Applying...' : 'Force Override'}
        </button>
      </div>
    </div>
  );
}
```

---

## Task 19: Frontend SystemPage

**Files:**
- Create: `frontend/src/pages/SystemPage.tsx`
- Modify: `frontend/src/App.tsx`

```tsx
// frontend/src/pages/SystemPage.tsx
import React from 'react';
import { SystemStatus } from '../components/SystemStatus';
import { RecoveryPanel } from '../components/RecoveryPanel';
import { useSystemStatus, useTradingPermissions } from '../hooks/useDegradation';

export function SystemPage() {
  const { data: status, isLoading: statusLoading } = useSystemStatus();
  const { data: permissions, isLoading: permissionsLoading } = useTradingPermissions();

  if (statusLoading || permissionsLoading) {
    return <div className="p-4">Loading system status...</div>;
  }

  return (
    <div className="p-4 space-y-6">
      <h1 className="text-2xl font-bold">System Status</h1>

      {status && (
        <div className="bg-white rounded-lg shadow p-4">
          <SystemStatus status={status} />
        </div>
      )}

      {permissions && (
        <div className="bg-white rounded-lg shadow p-4">
          <h2 className="text-lg font-semibold mb-4">Trading Permissions</h2>
          <div className="grid grid-cols-3 gap-2">
            {Object.entries(permissions.permissions).map(([action, allowed]) => (
              <div
                key={action}
                className={`p-2 rounded ${
                  allowed ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                }`}
              >
                {action}: {allowed ? 'Allowed' : 'Blocked'}
              </div>
            ))}
          </div>
        </div>
      )}

      <RecoveryPanel />
    </div>
  );
}
```

---

## Task 20: Integration Tests

**Files:**
- Create: `backend/tests/degradation/test_integration.py`

```python
# backend/tests/degradation/test_integration.py
"""Integration tests for graceful degradation system."""

import asyncio
import time

import pytest

from src.degradation.config import DegradationConfig
from src.degradation.models import (
    ComponentSource,
    EventType,
    ReasonCode,
    Severity,
    SystemMode,
    create_event,
)
from src.degradation.setup import init_degradation, shutdown_degradation


class TestEndToEndDegradation:
    """End-to-end integration tests."""

    @pytest.mark.asyncio
    async def test_cold_start_to_normal_flow(self):
        """System should start in RECOVERING and transition to NORMAL after recovery."""
        services = await init_degradation()

        # Should start in RECOVERING
        assert services.state_service.mode == SystemMode.RECOVERING

        # Simulate successful recovery
        # ... recovery steps ...

        await shutdown_degradation()

    @pytest.mark.asyncio
    async def test_broker_disconnect_triggers_safe_mode(self):
        """Broker disconnect should trigger SAFE_MODE_DISCONNECTED."""
        services = await init_degradation()

        # Simulate broker disconnect
        event = create_event(
            event_type=EventType.FAIL_CRIT,
            source=ComponentSource.BROKER,
            severity=Severity.CRITICAL,
            reason_code=ReasonCode.BROKER_DISCONNECT,
        )

        await services.state_service.handle_event(event)

        assert services.state_service.mode == SystemMode.SAFE_MODE_DISCONNECTED
        assert services.trading_gate.mode == SystemMode.SAFE_MODE_DISCONNECTED

        await shutdown_degradation()

    @pytest.mark.asyncio
    async def test_eventbus_drop_on_full(self):
        """EventBus should drop non-critical events when full."""
        config = DegradationConfig(event_bus_queue_size=1)
        services = await init_degradation(config)

        # Fill queue
        event1 = create_event(
            EventType.FAIL_SUPP,
            ComponentSource.ALERTS,
            Severity.WARNING,
            ReasonCode.ALERTS_CHANNEL_DOWN,
        )
        await services.event_bus.publish(event1)

        # This should be dropped
        event2 = create_event(
            EventType.FAIL_SUPP,
            ComponentSource.ALERTS,
            Severity.WARNING,
            ReasonCode.ALERTS_CHANNEL_DOWN,
        )
        result = await services.event_bus.publish(event2)

        assert result is False
        assert services.event_bus.drop_count == 1

        await shutdown_degradation()
```

---

## Task 21: Main.py Integration

**Files:**
- Modify: `backend/src/main.py`

Add degradation router and startup initialization:

```python
# Add to backend/src/main.py

from src.api.degradation import router as degradation_router
from src.degradation.setup import init_degradation, shutdown_degradation

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan for startup/shutdown."""
    # Initialize degradation system
    await init_degradation()

    # ... other startup ...

    yield

    # Shutdown degradation system
    await shutdown_degradation()

# Include router
app.include_router(degradation_router)
```

---

## Task 22: Final Verification

**Step 1: Run all tests**

```bash
cd backend && pytest tests/degradation/ -v
```

Expected: All tests PASS

**Step 2: Run full test suite**

```bash
cd backend && pytest
```

Expected: All tests PASS (294+ existing + new degradation tests)

**Step 3: Verify frontend**

```bash
cd frontend && npm test
```

Expected: All tests PASS

**Step 4: Final commit**

```bash
git add -A
git commit -m "feat(degradation): complete Slice 3.3 Graceful Degradation

Implements production hardening with Central Policy + Local Execution:
- SystemStateService as single source of truth
- TradingGate for unified permission checks
- EventBus with drop-on-full for non-blocking events
- Decision Matrix for mode transitions
- Force override with TTL
- Recovery orchestration with 4 stages
- Frontend dashboard with status and controls

Exit criteria verified:
- 6 modes + 3 levels state machine
- MODE_PRIORITY conflict resolution
- Cold start in RECOVERING
- Dual timestamps (wall + mono)
- MUST_DELIVER_EVENTS whitelist
- All thresholds from config"
```

---

## Summary

This implementation plan covers 22 tasks following TDD principles:

| # | Task | Files | Est. Tests |
|---|------|-------|-----------|
| 1 | Models | 3 | 8 |
| 2 | Config | 2 | 3 |
| 3 | EventBus | 2 | 6 |
| 4 | TradingGate | 2 | 10 |
| 5 | StateService | 2 | 8 |
| 6 | Breakers | 2 | 6 |
| 7 | Recovery | 2 | 5 |
| 8 | DB Buffer | 2 | 4 |
| 9 | Cache | 2 | 3 |
| 10 | Probes | 2 | 4 |
| 11 | Setup | 2 | 3 |
| 12 | API | 2 | 4 |
| 13 | Migration | 1 | 0 |
| 14 | FE Types | 1 | 0 |
| 15 | FE API | 1 | 0 |
| 16 | FE Hooks | 2 | 0 |
| 17 | FE Status | 1 | 0 |
| 18 | FE Panel | 1 | 0 |
| 19 | FE Page | 2 | 0 |
| 20 | Integration | 1 | 3 |
| 21 | Main.py | 1 | 0 |
| 22 | Verification | 0 | 0 |

**Total: ~35 files, ~67 new tests**

---

**Plan complete and saved to `docs/plans/2026-01-26-slice-3.3-graceful-degradation-implementation.md`. Two execution options:**

**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

**2. Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

**Which approach?**
